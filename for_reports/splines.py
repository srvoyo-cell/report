# -*- coding: utf-8 -*-
"""Splines.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QYbVulz6WEx_WvC-JBywJJLPLP-wC4MP
"""

import numpy as np
from matplotlib import pyplot as plt

X_1 = np.array([2.50, 2.80, 3.00, 3.30, 3.50, 3.90, 4.00,
              4.25, 4.50, 4.75, 5.00, 5.25, 5.50, 5.75, 6.00, 6.25])

Y_1 = np.array([6.10, 2.61, -0.15, -2.01, -2.69, -3.61, -3.47,
              -2.25, 0.19, 2.08, 5.88, 5.21, 4.15, 2.41, -0.17, -1.50])

plt.scatter(X_1, Y_1)
plt.grid()
plt.show()

def lagranz(x, y, t):
    z = 0
    for j in range(len(y)):
        p1 = 1
        p2 = 1
        for i in range(len(x)):
            if i == j:
                p1 = p1 * 1
                p2 = p2 * 1
            else:
                p1 = p1 * (t - x[i])
                p2 = p2 * (x[j] - x[i])
        z = z + y[j] * p1 / p2
    return z

grid = np.linspace(np.min(X_1), np.max(X_1), 500)
ynew = [lagranz(X_1, Y_1, i) for i in grid]
plt.plot(grid, ynew, c='red', label='Интерполяционный полином')
plt.scatter(X_1, Y_1, label='Значения в узлах')
plt.grid(True)
plt.legend()
plt.show()

plt.scatter(grid, ynew, c='red', label='Интерполяционный полином', s=5)
plt.grid()
plt.legend()
plt.show()

n = len(X_1)
h = np.diff(X_1)

A = np.zeros((n, n))
b = np.zeros(n)

A[0,0] = 1
A[-1,-1] = 1

for i in range(1, n-1):
    A[i, i-1] = h[i-1]
    A[i, i]   = 2*(h[i-1] + h[i])
    A[i, i+1] = h[i]
    b[i] = 6*((Y_1[i+1]-Y_1[i])/h[i] - (Y_1[i]-Y_1[i-1])/h[i-1])

def thomas_solver_matrix(A, b):
    n = A.shape[0]

    # извлечение диагоналей
    a = np.zeros(n-1)
    b_diag = np.zeros(n)
    c = np.zeros(n-1)

    for i in range(n):
        b_diag[i] = A[i, i]
        if i < n-1:
            c[i] = A[i, i+1]
            a[i] = A[i+1, i]

    # прямой ход
    cp = np.zeros(n-1)
    dp = np.zeros(n)

    cp[0] = -c[0] / b_diag[0]
    dp[0] = b[0] / b_diag[0]

    for i in range(1, n):
        denom = b_diag[i] - a[i-1] * cp[i-1]
        if i < n-1:
            cp[i] = c[i] / denom
        dp[i] = (b[i] - a[i-1] * dp[i-1]) / denom

    # обратный ход
    x = np.zeros(n)
    x[-1] = dp[-1]
    for i in range(n-2, -1, -1):
        x[i] = dp[i] - cp[i] * x[i+1]

    return x

def cubic_spline(x, X, Y, M):
    i = np.searchsorted(X, x) - 1
    if i < 0:
        i = 0
    elif i >= len(X)-1:
        i = len(X)-2

    h = X[i+1] - X[i]
    a = (X[i+1] - x) / h
    b = (x - X[i]) / h

    S = (a*Y[i] + b*Y[i+1] +
         ((a**3 - a) * M[i] + (b**3 - b) * M[i+1]) * (h**2) / 6)
    return S

solved = thomas_solver_matrix(A, b)
solved

xx = np.linspace(X_1[0], X_1[-1], 500)
yy = [cubic_spline(x, X_1, Y_1, solved) for x in xx]

plt.scatter(X_1, Y_1, color="red", label="Данные")
plt.plot(xx, yy, label="Кубический сплайн")
plt.legend()
plt.grid()
plt.show()

def func(x):
  return (np.sin(x)) / (x ** 2 + 1)

X_2 = np.linspace(-np.pi/2, 0, 15)
Y_2 = [func(x) for x in X_2]
plt.scatter(X_2, Y_2)
plt.grid()
plt.show()

grid = np.linspace(np.min(X_2), np.max(X_2), 500)
ynew = [lagranz(X_2, Y_2, i) for i in grid]
plt.plot(grid, ynew, c='red', label='Интерполяционный полином')
plt.scatter(X_2, Y_2, label='Значения в узлах')
plt.grid(True)
plt.legend()
plt.show()

plt.scatter(grid, ynew, c='red', label='Интерполяционный полином', s=4)
plt.grid()
plt.legend()
plt.show()

n = len(X_2)
h = np.diff(X_2)  # длины отрезков

A = np.zeros((n, n))
b = np.zeros(n)

A[0,0] = 1
A[-1,-1] = 1

for i in range(1, n-1):
    A[i, i-1] = h[i-1]
    A[i, i]   = 2*(h[i-1] + h[i])
    A[i, i+1] = h[i]
    b[i] = 6*((Y_2[i+1]-Y_2[i])/h[i] - (Y_2[i]-Y_2[i-1])/h[i-1])

solved_1 = thomas_solver_matrix(A, b)

xx = np.linspace(X_2[0], X_2[-1], 500)
yy = [cubic_spline(x, X_2, Y_2, solved_1) for x in xx]

plt.scatter(X_2, Y_2, color="red", label="Данные")
plt.plot(xx, yy, label="Кубический сплайн")
plt.legend()
plt.grid()
plt.show()

def calculate_errors(x_nodes, method='lagrange'):
    n = len(x_nodes)
    # Средние точки: x̄_i = (x_i + x_{i-1})/2 для i=1..n-1
    x_mid = np.zeros(n-1)
    for i in range(1, n):
        x_mid[i-1] = (x_nodes[i] + x_nodes[i-1]) / 2

    # Значения функции в средних точках
    f_mid = func(x_mid)

    # Интерполированные значения
    if method == 'lagrange':
        y_nodes = func(x_nodes)
        y_interp = np.array([lagranz(x_nodes, y_nodes, x) for x in x_mid])
    else:
        y_nodes = func(x_nodes)
        y_interp = np.array([cubic_spline(x, X_2, Y_2, solved) for x in x_mid])

    # Вычисление погрешности
    error_sum = 0
    for i in range(len(x_mid)):
        numerator = (y_interp[i] - f_mid[i]) ** 2
        denominator = f_mid[i] ** 2 + 0.1
        error_sum += numerator / denominator

    r = np.sqrt((1 / len(x_mid)) * error_sum)
    return r


n_values = [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
results = []

for n in n_values:
    x_nodes = np.linspace(-np.pi/2, 0.1, n)

    r_lagrange = calculate_errors(x_nodes, 'lagrange')
    r_spline = calculate_errors(x_nodes, 'spline')

    results.append((n, r_lagrange, r_spline))

    print(f"n = {n}: r_L = {r_lagrange:.6e}, r_s = {r_spline:.6e}")

# График
plt.figure(figsize=(8, 4))
n_vals = [r[0] for r in results]
r_l_vals = [np.log10(r[1]) for r in results]  # логарифм погрешности
r_s_vals = [np.log10(r[2]) for r in results]  # логарифм погрешности

plt.plot(np.log10(n_vals), r_l_vals, 'ro-', label='$lg(r_L)$ - Лагранж')
plt.plot(np.log10(n_vals), r_s_vals, 'bs-', label='$lg(r_s)$ - Сплайн')
plt.xlabel('lg(n)', fontsize=12)
plt.ylabel('lg(погрешность)', fontsize=12)
plt.title('Зависимость логарифма погрешности от lg(n)', fontsize=12)
plt.legend()
plt.grid(True)
plt.show()




for i in range(1, len(results)):
  n_prev, r_l_prev, r_s_prev = results[i-1]
  n_curr, r_l_curr, r_s_curr = results[i]

  ratio_l = r_l_prev / r_l_curr if r_l_curr != 0 else float('inf')
  ratio_s = r_s_prev / r_s_curr if r_s_curr != 0 else float('inf')

  print(f"При увеличении n с {n_prev} до {n_curr}:")
  print(f"  Погрешность Лагранжа уменьшилась в {ratio_l:.3f} раз")
  print(f"  Погрешность сплайна уменьшилась в {ratio_s:.3f} раз")

